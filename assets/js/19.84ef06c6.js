(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{352:function(e,t,v){"use strict";v.r(t);var a=v(33),_=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue高级特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue高级特性"}},[e._v("#")]),e._v(" Vue高级特性")]),e._v(" "),v("h2",{attrs:{id:"自定义v-model"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义v-model"}},[e._v("#")]),e._v(" 自定义v-model")]),e._v(" "),v("p",[e._v("在组件外部使用"),v("code",[e._v("v-model")]),e._v("绑定一个变量，在组件内部使用")]),e._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[e._v("model"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  prop"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'传入变量'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  event"),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'自定义方法'")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),v("h2",{attrs:{id:"nexttick"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[e._v("#")]),e._v(" $nextTick")]),e._v(" "),v("ul",[v("li",[e._v("Vue是异步渲染"),v("br"),e._v("\n如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑。"),v("code",[e._v("Vue")]),e._v("会在本轮数据更新后，再去异步更新视图")]),e._v(" "),v("li",[e._v("data改变之后，DOM不会立刻渲染")]),e._v(" "),v("li",[e._v("$nextTick会在DOM渲染之后被触发，以获取最新DOM节点")]),e._v(" "),v("li",[v("code",[e._v("nextTick")]),e._v("方法主要是使用了"),v("strong",[e._v("宏任务")]),e._v("和"),v("strong",[e._v("微任务")]),e._v("，定义了一个异步方法。多次调用"),v("code",[e._v("nextTick")]),e._v(" 会将方法存入队列中，通过这个异步方法清空当前队列。 所以这个"),v("code",[e._v("nextTick")]),e._v("方法就是异步方法")]),e._v(" "),v("li",[v("code",[e._v("nextTick")]),e._v("内部会先调用"),v("code",[e._v("Promise")]),e._v("，如果无法使用"),v("code",[e._v("Promise")]),e._v("会调用"),v("code",[e._v("MutationObserver")]),e._v("，如果无法使用"),v("code",[e._v("MutationObserver")]),e._v("会调用"),v("code",[e._v("setImmediate")]),e._v("，如果无法使用"),v("code",[e._v("setImmediate")]),e._v("会使用"),v("code",[e._v("setTimeout")])])]),e._v(" "),v("h2",{attrs:{id:"slot"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#slot"}},[e._v("#")]),e._v(" slot")]),e._v(" "),v("ul",[v("li",[e._v("基本使用")]),e._v(" "),v("li",[e._v("作用域插槽")]),e._v(" "),v("li",[e._v("具名插槽")])]),e._v(" "),v("h2",{attrs:{id:"动态组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态组件"}},[e._v("#")]),e._v(" 动态组件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v('<component :is="component-name" />')])]),e._v(" "),v("li",[e._v("需要根据数据，动态渲染的场景。即组件类型不确定")])]),e._v(" "),v("h2",{attrs:{id:"异步组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步组件"}},[e._v("#")]),e._v(" 异步组件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("import()")]),e._v("函数")]),e._v(" "),v("li",[e._v("按需加载，异步加载大组件")])]),e._v(" "),v("h2",{attrs:{id:"keep-alive-keep-alive-keep-alive"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-keep-alive-keep-alive"}},[e._v("#")]),e._v(" keep-alive "),v("code",[e._v("<keep-alive></keep-alive>")])]),e._v(" "),v("ul",[v("li",[e._v("缓存组件")]),e._v(" "),v("li",[e._v("频繁切换，不需要重复渲染")]),e._v(" "),v("li",[e._v("vue常见性能优化")])]),e._v(" "),v("h2",{attrs:{id:"mixin"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mixin"}},[e._v("#")]),e._v(" mixin")]),e._v(" "),v("ul",[v("li",[e._v("多个组件有相同的逻辑，抽离出来")]),e._v(" "),v("li",[e._v("mixin并不是完美的解决方案，会有一些问题\n"),v("ul",[v("li",[e._v("变量来源不明确，不利于阅读")]),e._v(" "),v("li",[e._v("多mixin可能造成命名冲突")]),e._v(" "),v("li",[e._v("mixin和组件可能出现多对多关系，复杂度较高")])])]),e._v(" "),v("li",[e._v("Vue3提出的composition API旨在解决这些问题")])])])}),[],!1,null,null,null);t.default=_.exports}}]);