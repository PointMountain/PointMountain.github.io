(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{358:function(e,n,t){"use strict";t.r(n);var s=t(33),r=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ol",[t("li",[e._v("ajax轮询 让浏览器隔一段时间就发送一次请求，询问服务器是否有新信息")]),e._v(" "),t("li",[e._v("长连接 类似轮询，区别是客户端发起连接后，如果没有信息，就一直不返回response给客户端，直到服务端有消息才返回，返回完之后，客户端再建立连接，周而复始")]),e._v(" "),t("li",[e._v("Server-Sent Events是通过服务端向客户端声明，接下来发送的信息是留信息，做到服务端主动推送信息，不过只能单向的由服务端传到客户端"),t("br"),e._v("\n客户端通过EventSource对象进行使用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let source = new EventSource(url, { withCredentials: true }) //可跨域，如果跨域的话可以设置第二个参数withCredentials是否传输cookie\n //EventSource实例中有只读属性readyState 0表示还未建立或正在重连 1表示连接已经建立可以接收数据，2表示连接已断，且不会重连\n source.addEventListener('open',(event)=>{\n\n })\n source.addEventListener('message',(event)=>{\n\n })\n source.addEventListener('error',()=>{\n\n })\n //EventSource还支持自定义事件\n source.close() //关闭连接\n")])])]),t("p",[e._v("服务端方面：\n必须设置"),t("code",[e._v("Content-type: text/event-stream")]),t("br"),e._v("\n返回的信息格式是："),t("code",[e._v("data|event|id|retry: value")]),t("br"),e._v("\n如果一次信息由多个message组成每个message直接用\\n\\n分隔"),t("br"),e._v("\ndata字段表示数据内容，event字段表示事件类型默认是message也可以自定义事件，id字段表示数据编号可以用lastEventId读取 如果断线的话就会发送一个带有Last-Event-ID请求头的信息，进行断线重连，retry字段指定浏览器重新发送连接的时间间隔")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let http = require(\'http\')\nhttp.createServer((res, req)=>{\n  let fileName = \'.\'+req.url\n  if(fileName === \'./stream\'){\n    res.writeHead(200, {\n      "Content-Type":"text/event-stream",\n      "Cache-Control":"no-cache",\n      "Connection":"keep-alive",\n      "Access-Control-Allow-Origin": \'*\',\n    });\n    res.write("retry: 10000\\n");\n    res.write("event: connecttime\\n");\n    res.write("data: " + (new Date()) + "\\n\\n");\n    res.write("data: " + (new Date()) + "\\n\\n");\n\n    interval = setInterval(function () {\n      res.write("data: " + (new Date()) + "\\n\\n");\n    }, 1000);\n\n    req.connection.addListener("close", function () {\n      clearInterval(interval);\n    }, false);\n  }\n}).listen(8080, \'127.0.0.1\')\n')])])]),t("ol",{attrs:{start:"4"}},[t("li",[e._v("WebSocket使用了websocket协议，全双工通信，实时性更强。更好的二进制支持。\n服务端")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let WebSocketServer = require('ws').Server\nlet wsServer = new WebSocketServer({port: 8888})\nwsServer.on('connection',socket =>{\n  console.log('连接成功');\n  socket.on('message', message =>{\n    console.log('接收到客户端消息:' + message);\n    socket.send('服务器回应:' + message)\n  })\n})\n")])])]),t("p",[e._v("客户端")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let ws = new WebSocket('ws: xxxx')\n //WebSocket实例中有属性readyState 0表示正在连接 1表示连接已经建立可以进行通信，2表示连接正在关闭 3表示连接已经关闭或者打开连接失败\n ws.addEventListener('open',(event)=>{\n    ws.send('Hello Server!');\n })\n ws.addEventListener('message',(event)=>{\n\n })\n ws.addEventListener('error',()=>{\n\n })\n ws.close() //关闭连接\n")])])]),t("p",[e._v("WebSocket只支持GET方法 且状态码为101表示协议切换\n请求时请求头有"),t("code",[e._v("Sec-WebSocket-Version")]),e._v("、"),t("code",[e._v("Sec-WebSocket-Key")]),e._v("\n响应头有"),t("code",[e._v("Sec-WebSocket-Accept")])])])}),[],!1,null,null,null);n.default=r.exports}}]);